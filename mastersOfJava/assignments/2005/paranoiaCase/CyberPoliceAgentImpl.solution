import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
* A proud member of the Cyber Police (tm) -- the unit responsible
* for solving various cybercrimes, from the light (such as illegally
* copying software) to the heinous (DOS attacks).
* @author Robert Bor
*/
public class CyberPoliceAgentImpl implements CyberPoliceAgent {
	/**
	* Constructor
	*/
	public CyberPoliceAgentImpl() {
		// needs no implementation
	}
	/**
	* The Cyber Policy Agent will set up a stakeout location in the
	* company and see if he can catch the criminal. The list of criminals
	* is returned as an array of employees
	* @param company the stakeout location
	* @return the list of employees checking in illegal bytestreams
	*/
	public Employee[] performStakeOut(Company company) {
		List evilEmployeeList = new ArrayList();
		// First tag the leg byte streams
		Map legalStreams = new TreeMap();
		CompanyByteStream[] byteStreams = company.getLegalByteStreams();
		for (int pos = 0; pos < byteStreams.length; pos++) {
			CompanyByteStream currentByteStream = byteStreams[pos];
			SecurityCodeAlgorithm sca = new SecurityCodeAlgorithmImpl();
			String securityCode = currentByteStream.calculateSecurityCode(sca);
			byteStreams[pos].setSecurityCode(securityCode);
			legalStreams.put(currentByteStream.getName(), currentByteStream);
		}
		// Then check the byte stream employees try to check in
		Iterator checkinEvents = company.getCheckinEvents();
		while (checkinEvents.hasNext()) {
			CheckinEvent checkinEvent = (CheckinEvent)checkinEvents.next();
			Employee checkinEmployee = checkinEvent.getEmployee();
			CompanyByteStream checkinStream = checkinEvent.getByteStream();
			String currentName = checkinStream.getName();
			CompanyByteStream matchStream = (CompanyByteStream)legalStreams.get(currentName);
			if (matchStream == null) {
				System.out.println("* Name: \""+currentName+"\" does not exist. Illegal");
				evilEmployeeList.add(checkinEmployee);
				continue;
			}
			SecurityCodeAlgorithm sca = new SecurityCodeAlgorithmImpl();
			String checkinSecurityCode = checkinStream.calculateSecurityCode(sca);
			checkinStream.setSecurityCode(checkinSecurityCode);
			if (!matchStream.equals(checkinStream)) {
				System.out.println("* Name: \""+currentName+"\" has a different security code. Illegal");
				System.out.println("  checkin stream code: "+checkinStream.getSecurityCode());
				System.out.println("  legal stream code:   "+matchStream.getSecurityCode());
				evilEmployeeList.add(checkinEmployee);
				continue;
			}
			System.out.println("* Name: \""+currentName+"\" is legal");
		}
		Employee[] evilEmployees = new Employee[evilEmployeeList.size()];
		return (Employee[])evilEmployeeList.toArray(evilEmployees);
	}
	/**
	* This algorithm is passed by the CyberPoliceAgent to a CompanyByteStream
	* in order to determine the security code. This code can be used to
	* compare byte streams
	*/	
	public class SecurityCodeAlgorithmImpl implements SecurityCodeAlgorithm {
		private MessageDigest md;

		/**
		* Constructor
		*/
		public SecurityCodeAlgorithmImpl() {
			try {
				md = MessageDigest.getInstance("MD5");
			} catch (NoSuchAlgorithmException err) {
				System.out.println("The MD5 algorithm is not available");
			}
		}
		/** 
		* The method is called by CompanyByteStream to feed chunks of data
		* to the SecurityCodeAlgorithm. The algorithm is expected to be 
		* able to deal with these chunks. Note that the chunks are of
		* indeterminate size. Ie, a chunk can be both 4 bytes, but it could
		* just as well be 100 bytes.
		* @param byteStream the chunk fed to the algorithm
		*/
		public void feedData(byte[] byteStream) {
			md.update(byteStream);
		}
		/**
		* Returns the security code calculated by the algorithm. The class
		* had its feedData method called at least once, before a value
		* is legally available.
		* @return the security code calculated by the algorithm
		*/ 
		public String getSecurityCode() {
			return convertBytesToString(md.digest());
		}
		/**
		* Converts a byte array to a String. This method is used for
		* debugging purposes the cyber police
		* @param byteStream byte array to be converted to text
		* @return the text representation of the byte array
		*/
		protected String convertBytesToString(byte[] byteStream) {
			return Utils.byteArrayToString(byteStream);
		}
	}
}
